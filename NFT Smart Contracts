anchor init nft_marketplace
cd nft_marketplace
use anchor_lang::prelude::*;
use anchor_lang::solana_program::system_program;

declare_id!("YourProgramIDHere");

#[program]
pub mod nft_marketplace {
    use super::*;

    pub fn create_nft(ctx: Context<CreateNFT>, metadata: String) -> ProgramResult {
        let nft = &mut ctx.accounts.nft;
        nft.owner = *ctx.accounts.user.key;
        nft.metadata = metadata;
        Ok(())
    }

    pub fn list_nft(ctx: Context<ListNFT>, price: u64) -> ProgramResult {
        let nft = &mut ctx.accounts.nft;
        nft.is_listed = true;
        nft.price = price;
        Ok(())
    }

    pub fn buy_nft(ctx: Context<BuyNFT>) -> ProgramResult {
        let nft = &mut ctx.accounts.nft;
        nft.owner = *ctx.accounts.buyer.key;
        nft.is_listed = false;
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateNFT<'info> {
    #[account(init, payer = user, space = 8 + 32 + 32)]
    pub nft: Account<'info, NFT>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ListNFT<'info> {
    #[account(mut, has_one = owner)]
    pub nft: Account<'info, NFT>,
    pub owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct BuyNFT<'info> {
    #[account(mut, has_one = owner)]
    pub nft: Account<'info, NFT>,
    #[account(mut)]
    pub buyer: Signer<'info>,
    #[account(mut)]
    pub owner: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NFT {
    pub owner: Pubkey,
    pub metadata: String,
    pub price: u64,
    pub is_listed: bool,
}
pub fn stake_nft(ctx: Context<StakeNFT>) -> ProgramResult {
    let nft = &mut ctx.accounts.nft;
    let staking_account = &mut ctx.accounts.staking_account;
    
    nft.is_listed = false; // Remove from sale if staked
    staking_account.owner = nft.owner;
    staking_account.nft_token_id = nft.key();
    staking_account.stake_start_time = Clock::get()?.unix_timestamp;

    Ok(())
}

#[derive(Accounts)]
pub struct StakeNFT<'info> {
    #[account(mut, has_one = owner)]
    pub nft: Account<'info, NFT>,
    #[account(init, payer = owner, space = 8 + 32 + 32 + 8)]
    pub staking_account: Account<'info, StakingAccount>,
    #[account(mut)]
    pub owner: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct StakingAccount {
    pub owner: Pubkey,
    pub nft_token_id: Pubkey,
    pub stake_start_time: i64,
}
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Mint, Token, TokenAccount, Transfer};

declare_id!("YourProgramIDHere");

#[program]
pub mod nft_defi_platform {
    use super::*;

    // Function for staking an NFT as collateral
    pub fn stake_nft_as_collateral(ctx: Context<StakeNFTAsCollateral>, loan_amount: u64) -> ProgramResult {
        let nft = &mut ctx.accounts.nft;
        let loan_account = &mut ctx.accounts.loan_account;

        require!(loan_amount > 0, ErrorCode::InvalidLoanAmount);

        loan_account.borrower = *ctx.accounts.user.key;
        loan_account.nft_token_id = nft.key();
        loan_account.loan_amount = loan_amount;
        loan_account.loan_start_time = Clock::get()?.unix_timestamp;
        loan_account.is_active = true;

        // Transfer loan amount to the borrower
        let cpi_accounts = Transfer {
            from: ctx.accounts.lending_pool.to_account_info(),
            to: ctx.accounts.borrower_token_account.to_account_info(),
            authority: ctx.accounts.platform_authority.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, loan_amount)?;

        Ok(())
    }

    // Function for repaying the loan
    pub fn repay_loan(ctx: Context<RepayLoan>) -> ProgramResult {
        let loan_account = &mut ctx.accounts.loan_account;

        require!(loan_account.is_active, ErrorCode::LoanNotActive);

        let loan_duration = Clock::get()?.unix_timestamp - loan_account.loan_start_time;
        let interest_due = calculate_interest(loan_account.loan_amount, loan_duration);

        // Transfer repayment (loan + interest) from borrower
        let total_repayment = loan_account.loan_amount + interest_due;
        let cpi_accounts = Transfer {
            from: ctx.accounts.borrower_token_account.to_account_info(),
            to: ctx.accounts.lending_pool.to_account_info(),
            authority: ctx.accounts.borrower.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, total_repayment)?;

        // Mark the loan as repaid
        loan_account.is_active = false;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct StakeNFTAsCollateral<'info> {
    #[account(mut, has_one = borrower)]
    pub nft: Account<'info, NFT>,
    #[account(init, payer = user, space = 8 + 32 + 32 + 64 + 8)]
    pub loan_account: Account<'info, LoanAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(mut)]
    pub lending_pool: Account<'info, TokenAccount>,  // Pool holding the tokens to lend
    #[account(mut)]
    pub borrower_token_account: Account<'info, TokenAccount>,
    pub platform_authority: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RepayLoan<'info> {
    #[account(mut, has_one = borrower)]
    pub loan_account: Account<'info, LoanAccount>,
    #[account(mut)]
    pub borrower: Signer<'info>,
    #[account(mut)]
    pub borrower_token_account: Account<'info, TokenAccount>,
    #[account(mut)]
    pub lending_pool: Account<'info, TokenAccount>,
    pub token_program: Program<'info, Token>,
}

#[account]
pub struct LoanAccount {
    pub borrower: Pubkey,
    pub nft_token_id: Pubkey,
    pub loan_amount: u64,
    pub loan_start_time: i64,
    pub is_active: bool,
}

fn calculate_interest(loan_amount: u64, loan_duration: i64) -> u64 {
    let interest_rate: u64 = 5; // Example interest rate of 5%
    (loan_amount * (interest_rate as u64) * (loan_duration as u64)) / (365 * 24 * 60 * 60)
}
pub fn stake_nft_for_yield(ctx: Context<StakeNFTForYield>) -> ProgramResult {
    let nft = &mut ctx.accounts.nft;
    let yield_account = &mut ctx.accounts.yield_account;

    nft.is_staked = true;
    yield_account.owner = *ctx.accounts.user.key;
    yield_account.nft_token_id = nft.key();
    yield_account.stake_start_time = Clock::get()?.unix_timestamp;

    Ok(())
}

pub fn claim_yield(ctx: Context<ClaimYield>) -> ProgramResult {
    let yield_account = &mut ctx.accounts.yield_account;
    let current_time = Clock::get()?.unix_timestamp;

    let yield_duration = current_time - yield_account.stake_start_time;
    let rewards = calculate_rewards(yield_duration);

    // Transfer rewards (example token USDC) to user
    let cpi_accounts = Transfer {
        from: ctx.accounts.yield_pool.to_account_info(),
        to: ctx.accounts.user_token_account.to_account_info(),
        authority: ctx.accounts.platform_authority.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
    token::transfer(cpi_ctx, rewards)?;

    yield_account.stake_start_time = current_time; // Reset staking timer

    Ok(())
}

#[derive(Accounts)]
pub struct StakeNFTForYield<'info> {
    #[account(mut)]
    pub nft: Account<'info, NFT>,
    #[account(init, payer = user, space = 8 + 32 + 32 + 8)]
    pub yield_account: Account<'info, YieldAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ClaimYield<'info> {
    #[account(mut)]
    pub yield_account: Account<'info, YieldAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    #[account(mut)]
    pub yield_pool: Account<'info, TokenAccount>,
    #[account(mut)]
    pub user_token_account: Account<'info, TokenAccount>,
    pub platform_authority: AccountInfo<'info>,
    pub token_program: Program<'info, Token>,
}

#[account]
pub struct YieldAccount {
    pub owner: Pubkey,
    pub nft_token_id: Pubkey,
    pub stake_start_time: i64,
}

fn calculate_rewards(stake_duration: i64) -> u64 {
    let reward_rate: u64 = 10; // Example reward rate of 10 tokens per day
    (stake_duration as u64 / (24 * 60 * 60)) * reward_rate
}

